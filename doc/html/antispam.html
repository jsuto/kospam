<html>
<title>Antispam decision</title>
<link rel="stylesheet" type="text/css" href="style.css">
<body bgcolor=white text=darkblue vlink=#AC003A>
<blockquote>

<h1><img src="logo.png"></h1>

<h2>Antispam decision</h2>

Clapf uses a statistical algorithm* to decide whether the incoming email is spam or not.
It only marks the message by inserting a new message header called "X-Clapf-spamicity"
indicating what score the email has. If the probability is above a certain limit clapf also
adds the "X-Clapf-spamicity: Yes" flag to the message header. This second header is
just for the easy spam recognition.<p>

*: I thought clapf was a Bayesian filter, but later I realised that it was not. It is
a statistical filter, and it uses the inverse chi-square algorithm instead of the
Bayesian chain rule.<p>

You may use the following snippet in ~/.mailfilter with maildrop to put spam to your
junk folder:<p>

<pre>

if(/^X-Clapf-spamicity: Yes/:h)
{
        to "mail/junk"
}
</pre>

<p>

clapf only marks the message instead rejecting or removing it. Though statistical filters
are famous for their high accuracy, there is no 100.00% perfect anti-spam measure.
It is up to the user what to do with messages marked as spam: can be delivered
to the user and put into the junk folder or move it to the spam quarantine.<p>

<strong>Training</strong><p>

Before using any statistical filter it must be trained. Read the <a href="training.html">
training paper</a> how to create the initial token database and how to train it further.<p>

You may test the antispam decision mechanism with a single RFC-822 format message. Copy your
existing configuration file as 1.conf and adjust pathes if necessary, then run:<p>

<pre>
./spamtest /usr/local/etc/clapf.conf messagefile
</pre>

test.c was compiled with the DEBUG option to see verbose messages.<p>

<strong>Statistical internals</strong><p>

<pre>
ham probability = (the number of ham emails containing the word w) / (the total number of ham emails)
spam probability = (the number of spam emails containing the word w) / (the total number of spam emails)

probability of a given word (pn) = spam probability / (ham probability + spam probability)
</pre>

Then clapf counts the spaminess and the haminess of the most interesting tokens:<p>

<pre>
spaminess: P = (1-p1) * (1-p2) * .... * (1-pn)

non-spaminess: Q = p1 * p2 * .... *pn
</pre>

Now clapf applies the inverse <a href="http://garyrob.blogs.com/chi2p.py">chi-square
algorithm</a> and computes a combined indicator (I):

<pre>
H = chi2inv(-2 * ln Q, 2*n);

S = chi2inv(-2 * ln P, 2*n);

I = (1 + H - S) / 2;
</pre>

What to do with rare words?

<pre>
p(w) = ( s * x + n * p(w) ) / (s+n)
</pre>

where x=0.5, s=1, n: number of word occurence<p>


<strong>Implementation issues</strong><p>

clapf parses and tokenize the incoming message. For better accuracy clapf
creates additional phrases from consecutive tokens. Look at the following
text: "How nice day!"<p>

Now we have 5 tokens: "How", "nice", "day!", "How+nice" and "nice+day!"<p>

Clapf creates two tables: one for the phrases and URLs and one for single
tokens and URLs. First it calculates a spamicity value from the phrase table
and uses the single token table only if we are unsure. Then it chooses the
value with greater deviation from the neutral 0.5<p>

clapf discards some tokens:<p>

<ul>
<li>numeric only tokens
<li>tokens with shorter length than 3
<li>tokens with longer length then MAX_WORD_LEN (19)
<li>tokens occuring only once in the spam or in the ham folder
</ul>

Case sensitivity:<p/>

By default clapf converts all token to lower case. It can be override with the
--enable-case configure option.<p/>

Degeneration:<p/>

clapf degenerates a token to a simpler form if it ends with a punctuation
character, eg. both "Free!!!!!" and "FrEE!!" become "free!"<p/>

<strong>Performance</strong><p>

You should put clapf's directory to a separate (lightly loaded) disk.
If you want even better performance put your whole queue directory
(/opt/av/tmp by default) to memory filesystem.

You need at least max_message_size * (max_paralel_delivery + 1).
Eg. 8M * (10+1) = 88M<p>

<pre>
/etc/fstab:

/dev/shm        /opt/av/tmp       tmpfs   defaults,size=128M       0	0
</pre>



<strong>Notes on parsing email</strong><p>

There is a custom tailorable array - called invalid_junk_characters (look ijc.h) -
you can fill with garbage characters occuring messages with a completely
invalid characters for your language, display. I myself fill it with
Chinese, Korean, Japanese, ... stuff.<br>
If this junk exceeds a certain (configurable) limit clapf marks the message as spam.<p>

The parser routine is able to skip some (configured) headers (look shdr.h).
My messages contain some headers from a commercial spam filter
I don't trust. You may list headers you want to ignore just edit shdr.h
then recompile clapf.<p>


<strong>Recommended reading</strong><p>

(1) Bayesian Filtering Example, Using Bayes' Formula to keep spam out of your Inbox:

<a href="http://www.process.com/precisemail/bayesian_example.htm">http://www.process.com/precisemail/bayesian_example.htm</a><p>

(2) Spam Detection:

<a href="http://radio.weblogs.com/0101454/stories/2002/09/16/spamDetection.html">http://radio.weblogs.com/0101454/stories/2002/09/16/spamDetection.html</a><p>

(3) A Statistical Approach to the Spam Problem:

<a href="http://www.linuxjournal.com/article/6467">http://www.linuxjournal.com/article/6467</a><p>

(4) A Plan for Spam:

<a href="http://www.paulgraham.com/spam.html">http://www.paulgraham.com/spam.html</a><p>

(5) Better Bayesian Filtering:

<a href="http://www.paulgraham.com/better.html">http://www.paulgraham.com/better.html</a><p>

(6) Filters vs. Blacklists:

<a href="http://www.paulgraham.com/falsepositives.html">http://www.paulgraham.com/falsepositives.html</a><p>

(7) The Spam-Filtering Accuracy Plateau at 99.9% Accuracy and How to Get Past It:

<a href="http://crm114.sourceforge.net/Plateau_Paper.html">http://crm114.sourceforge.net/Plateau_Paper.html</a><p>

<center><a href="index.html">home</a></center><p>

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-1610427-1";
urchinTracker();
</script>


<blockquote>
</body></html>
